Router

When you put path / and /about, then both the page will be displayed. So use exact to prevent this.

------------Basics------------

index.js

import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

const rootElement = document.getElementById("root");

ReactDOM.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
  rootElement
);


App.js

import React from 'react';
import { Routes, Route } from 'react-router-dom';
import Navbar from './Navbar';
import Home from './Home';
import About from './About';

const App = () => {
  return (
    <div>
      <Navbar />
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        {/* Add more routes as needed */}
      </Routes>
    </div>
  );
};

export default App;


Home.js

import React from 'react';

const Home = () => {
  return (
    <div>
      <h1>I am home</h1>
    </div>
  );
};

export default Home;

About.js

import React from 'react';

const About = () => {
  return (
    <div>
      <h1>About Page</h1>
      <p>This is the about page content.</p>
    </div>
  );
};

export default About;


Navbar.js

import React from 'react';
import { Link } from 'react-router-dom';

const Navbar = () => {
  return (
    <nav>
      <ul>
        <li>
          <Link to="/">Home</Link>
        </li>
        {/* Add more navigation links as needed */}
      </ul>
    </nav>
  );
};

export default Navbar;

------------NavLink------------

Navbar.js with NavLink

import React from 'react';
import { NavLink } from 'react-router-dom';
import './Navbar.css'; // Import CSS file for styling

const Navbar = () => {
  return (
    <nav>
      <ul>
        <li>
          <NavLink exact to="/" activeClassName="active">Home</NavLink>
        </li>
        <li>
          <NavLink exact to="/about" activeClassName="active">About</NavLink>
        </li>
        {/* Add more navigation links as needed */}
      </ul>
    </nav>
  );
};

export default Navbar;

Navbar.css

.navbar ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

.navbar li {
  display: inline;
  margin-right: 10px;
}

.navbar a {
  text-decoration: none;
  color: blue; /* Default color */
}

.navbar a.active {
  color: green; /* Active route color */
}

------------Points for NavLink and active class------------

1) First Way

In React Router v6, the className prop of the NavLink component can be a function. When you provide a function to the className prop, React Router will call this function with an object containing various properties. One of these properties is isActive, which indicates whether the current location matches the to prop of the NavLink.

Here's how it works:

className Prop as a Function: When you pass a function to the className prop of NavLink, React Router will call this function with an object containing properties related to the link.

Object with Properties: The object passed to the function contains properties like isActive, href, location, etc. These properties provide information about the link and the current routing state.

Accessing isActive Property: Within the function, you can access the isActive property from the object to determine if the link is currently active.

Conditional Styling: Based on the value of isActive, you can return different class names from the function. If isActive is true, it means the link is active, and you can return a class name for active styling. If isActive is false, you can return a class name for inactive styling.

So, the className function receives an object from React Router, and it accesses the isActive property from this object to determine the appropriate class name to apply to the NavLink based on whether it's active or not. This mechanism allows for dynamic styling of navigation links based on the current routing state.

<NavLink 
  to="about"
  className={({ isActive }) => (isActive ? "activeClassName" : "className")}
>
  About
</NavLink>


2) Second Way

Here's how it works:

activeClassName (string): This prop specifies the name of the CSS class that will be applied to the NavLink when it is active. It's not a boolean; rather, it's a string value representing the class name.

When the NavLink is active (i.e., when the current URL matches the to prop of the NavLink), React Router will automatically add the class specified in activeClassName to the NavLink component.

You can define the styles for the active link in your CSS file using this class name. This allows you to apply specific styling to the active link, such as changing its color, background, or any other CSS properties you desire.

So, in the code you provided:

javascript
Copy code
<NavLink exact to="/" activeClassName="active">Home</NavLink>
The "active" string passed to the activeClassName prop is the name of the CSS class that will be applied to the NavLink when it's active. It's not a boolean; it's simply the name of the CSS class you want to use for styling the active link.

------------useNavigate and replace------------

In React Router v6, the useNavigate hook provides an option to replace the current entry in the history stack when navigating to a new route. This means that the current route will be replaced in the browser's history instead of creating a new entry.

Here's how to use the replace: true option with useNavigate:

Import useNavigate: Import the useNavigate hook from react-router-dom.
javascript
Copy code
import { useNavigate } from 'react-router-dom';
Call useNavigate to Get the Navigation Function: Inside your component, call useNavigate() to get the navigation function.
javascript
Copy code
const navigate = useNavigate();
Use the navigate Function with replace: true Option: Pass an object with the replace property set to true as the second argument to the navigate function.
javascript
Copy code
navigate('/about', { replace: true });
Here's a complete example:

javascript
Copy code
import React from 'react';
import { useNavigate } from 'react-router-dom';

const MyComponent = () => {
  const navigate = useNavigate();

  const handleButtonClick = () => {
    // Replace the current entry in the history stack with the "/about" route
    navigate('/about', { replace: true });
  };

  return (
    <div>
      <h1>My Component</h1>
      <button onClick={handleButtonClick}>Go to About</button>
    </div>
  );
};

export default MyComponent;
In this example, when the button is clicked, the handleButtonClick function calls navigate('/about', { replace: true }), causing the application to navigate to the "/about" route while replacing the current entry in the history stack. This means that if the user navigates back, they will skip the route that was replaced.

User
This means that if the user navigates back, they will skip the route that was replaced.

Points for NavLink and active class

Normal Navigation:

When you navigate to a new route without using replace: true, a new entry is added to the browser's history stack. This means that if the user clicks the back button in the browser, they will go back to the previous route.
Navigation with replace: true:

When you navigate to a new route using replace: true, the current entry in the history stack is replaced with the new route instead of adding a new entry. This means that the user won't see the replaced route when they click the back button in the browser.
Let's illustrate this with an example:

Normal Navigation:

Suppose the user navigates from "/home" to "/about" using a normal navigation.
The browser's history stack now contains two entries: "/home" and "/about".
If the user clicks the back button, they will go back to "/home" because it's the previous entry in the history stack.
Navigation with replace: true:

Now, suppose the user navigates from "/home" to "/about" using replace: true.
The browser's history stack contains only one entry: "/about", because the "/home" entry was replaced.
If the user clicks the back button, they will not see "/home" because it was replaced, so they will go back to the page before "/home", effectively skipping it.
In summary, using replace: true with useNavigate replaces the current entry in the browser's history stack with the new route, and if the user navigates back, they will skip the replaced route. This can be useful in certain scenarios where you don't want certain routes to appear in the navigation history.
