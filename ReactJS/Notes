React JS

-----------------------------------------------Naming Convention--------------------------------------------------------------------------------------------

App Name - Lowercase Letters: Use lowercase letters to avoid issues with case sensitivity in different operating systems.
           Hyphens: Use hyphens to separate words for readability. Avoid underscores and spaces.
           Ex - my-app

Variables - CamelCase
            Ex - const userName = "John";
                 const totalAmount = 100;

Constants - Use UPPERCASE and underscores for constant values.
            const MAX_USERS = 100;
            const API_URL = "https://api.example.com";

env variables - REACT_APP_  is compulsary
                Must create .env file in root folder
                No need for '' or "" 
                Do not put , or ; at the end
                Ex - REACT_APP_API=23aCFF56
                     REACT_APP_INFORMATION=Apple

Function - CamelCase
           Verb-Noun Structure
           Ex - function fetchUserData() {
                // function implementation
                }

          const updateProfile = (user) => {
          // function implementation
          };

Component - Use PascalCase for React component names.
            Ex - function UserProfile() {
                 return <div>User Profile</div>;
                 }

                const Dashboard = () => {
                return <div>Dashboard</div>;
                };

Event Handlers - Prefix event handler functions with handle.
                 Ex - function handleClick() {
                      // handle click event
                      }

                      const handleChange = (event) => {
                      // handle change event
                      };

State Variables - Use descriptive names for state variables and their update functions, often in pairs with useState.
                  Ex - const [count, setCount] = useState(0);

Custom Hooks - Prefix custom hooks with use.
               Ex - function useUserData(userId) {
                    // custom hook implementation
                    }

                    const useFetchData = (url) => {
                    // custom hook implementation
                    };

-----------------------------------------------Commands--------------------------------------------------------------------------------------------

1)Initially creating an app
npx create-react-app appname
npm start

2)After clone from git
npm start
npm install

3)Move to production
npm run build

node --version
Babel is a Javascript Compiler that converts newest Javascript into good old Javascript

index.js
<div id="root"></div> Whole our Javascript lives here.

rafce   rfc

npm start -> Starts the development server
npm run build -> Bundles the app into satatic files for production -> This gives Build Folder to deploy

Keep React Component name in Caps

-----------------------------------------------JSX Rules--------------------------------------------------------------------------------------------

JSX rules
return single element and must return something
div section article or Fragment <> </> 
camelCase for html attribute className instead of class  htmlFor instead of for
For JS {}

-----------------------------------------------Structure--------------------------------------------------------------------------------------------


import React from 'react';
import ReactDom from 'react-dom';

function Greeting()
{
return(
<div>
<Person/>
<Message/>
</div>
);
}

const Person = () => <h2>Dia</h2>;
const Message = () =>{
return <p> This is my message</p>;
};

ReactDom.render(<Greeting/>, document.getElementById('root));

-----------------------------------------------Points--------------------------------------------------------------------------------------------

<h1 style={{backgroundColor: "lightblue"}}>Hello Style!</h1>

class MyHeader extends React.Component {
  render() {
    const mystyle = {
      color: "white",
      backgroundColor: "DodgerBlue",
      padding: "10px",
      fontFamily: "Arial"
    };
    return (
      <div>
      <h1 style={mystyle}>Hello Style!</h1>
      <p>Add a little style!</p>
      </div>
    );
  }
}

const Title = 'I am the heading'
<h1>{Title}</h1>
<h1>{Title.toUpperCase()}</h1>
<h1>{6+6}</h1>

Remember In return you have JSX
So write javascript in {}
Also statement should return something  ex - {let a = 6;} not valid 
                                        ex - {console.log("Hello")} valid

-----------------------------------------------Props--------------------------------------------------------------------------------------------

You can pass props as bunny also.

props are objects.


const Book = ({img, title, author}) =>      Destructuring in js
{
//const {img, title, author} = props;
return (
<article className='book'>
<img src={img} alt='' />
<h1>{title}</h1>
<h4>{author}</h4>
</article>
}
);
};

<Book title="My Diary" price={22}/>


<Book title="My Diary" /> If we don't pass any value, the price will not be displayed.


const firstBook = {
images: "...",
title: "Happy World"
}

<img src={props.images} alt='' />    //Instead of props you can use values, datas

No need to maintain props pass order and use order.

const objArr = [{},{},]
const strArr = ["",""]

return <section className="booklist">{objArr}</section>;   invalid
return <section className="booklist">{strArr}</section>;   valid 


-----------------------------------------------Children--------------------------------------------------------------------------------------------


If in some components we want to have something extra we can make use of children

<Book
img={}
title={}
author={}
>
<p> This Child will be displayed for this Book only </p>
</Book>
<Book
img={}
title={}
author={}
/>




const Book = ({img, title, author, children}) =>
{
//const {img, title, author} = props;
return (
<article className='book'>
<img src={img} alt='' />
<h1>{title}</h1>
<h4>{author}</h4>
{children}
</article>
}
);
};


-----------------------------------------------Export--------------------------------------------------------------------------------------------


when we use export default , then while importing we can change the name.

But if we use only export then names must match.


-----------------------------------------------Using Maps--------------------------------------------------------------------------------------------

const books = [
{ id:1,
img:'',
title:'',
author:'',
},
{ id:2,
img:'',
title:'',
author:'',
},
{ id:3,
img:'',
title:'',
author:'',
},
]

function BookList()
{
return(
<section className ='booklist'>
{
books.map((book,index) => {                               props is an object, but here you are passing book object in props object
return <Book key={index} book={book}></Book>;
})}
);
}

const Book = (props) =>
{
const {img, title, author} = props.book;
return (
<article className='book'>
<img src={img} alt='' />
<h1>{title}</h1>
<h4>{author}</h4>
</article>
}
);
};






const books = [
{ id:1,
img:'',
title:'',
author:'',
},
{ id:2,
img:'',
title:'',
author:'',
},
{ id:3,
img:'',
title:'',
author:'',
},
]

function BookList()
{
return(
<section className ='booklist'>
{
books.map((book,index) => {

//return <Book key={book.id} {...book}></Book>;            Using destructure in js   
})}
);
}

const Book = (props) =>
{
const {img, title, author} = props;
return (
<article className='book'>
<img src={img} alt='' />
<h1>{title}</h1>
<h4>{author}</h4>
</article>
}
);
};



-----------------------------------------------Hooks--------------------------------------------------------------------------------------------

Hooks are functions that let you “hook into” React state and lifecycle features from function components. Hooks don't work inside classes — they let you use React without classes.
Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed. Although Hooks generally replace class components, there are no plans to remove classes from React.



-----------------------------------------------useState--------------------------------------------------------------------------------------------

useState is a function which returns array. First val is undefined and second is a function.            


useState Array :-

import React from 'react';
import { data } from '../../../data';
const UseStateArray = () => {
  const [people, setPeople] = React.useState(data);

  const removeItem = (id) => {
    let newPeople = people.filter((person) => person.id !== id);
    setPeople(newPeople);
  };
  return (
    <>
      {people.map((person) => {
        const { id, name } = person;
        return (
          <div key={id} className='item'>
            <h4>{name}</h4>
            <button onClick={() => removeItem(id)}>remove</button>
          </div>
        );
      })}
      <button className='btn' onClick={() => setPeople([])}>
        clear items
      </button>
    </>
  );
};

export default UseStateArray;


useState Object :-

import React, { useState } from 'react';

const UseStateObject = () => {
  const [person, setPerson] = useState({
    name: 'peter',
    age: 24,
    message: 'random message',
  });

  // const [name,setName] = useState('peter')
  // const [age,setAge] = useState(24)
  // const [message,setMessage] = useState('random message')

  const changeMessage = () => {
    setPerson({ ...person, message: 'hello world' });
    // setMessage('hello world')
  };

  return (
    <>
      <h3>{person.name}</h3>
      <h3>{person.age}</h3>
      <h4>{person.message}</h4>
      <button className='btn' onClick={changeMessage}>
        change message
      </button>
    </>
  );
};

export default UseStateObject;



useState Counter :-

import React, { useState } from 'react';

const UseStateCounter = () => {
  const [value, setValue] = useState(0);

  const reset = () => {
    setValue(0);
  };

  const complexIncrease = () => {
    setTimeout(() => {
      // setValue(value + 1);
      setValue((prevState) => {
        return prevState + 1;
      });
    }, 2000);
  };

  return (
    <>
      <section style={{ margin: '4rem 0' }}>
        <h2>regular counter</h2>
        <h1>{value}</h1>
        <button className='btn' onClick={() => setValue(value - 1)}>
          decrease
        </button>
        <button className='btn' onClick={reset}>
          reset
        </button>
        <button className='btn' onClick={() => setValue(value + 1)}>
          increase
        </button>
      </section>
      <section style={{ margin: '4rem 0' }}>
        <h2>more complex counter</h2>
        <h1>{value}</h1>
        <button className='btn' onClick={complexIncrease}>
          increase later
        </button>
      </section>
    </>
  );
};

export default UseStateCounter;





<div className={`btn-warning ${props.mode}`}></div>

If you want to create a function in setState, you can do it.

const [people, setPeople] = useState(data);

const removeItem = (id) =>
{
setPeople((oldPeople) => {                                                         oldPeople is the previous state
let newPeople = oldPeople.filter((person) => person.id !== id);
return newPeople;                                                                  return is important to set the new state
});
};



-----------------------------------------------useEffect--------------------------------------------------------------------------------------------


useEffect - Any work outside the componenet - fetch , document title, etc.
            To do something after a state change


useEffect :-

import React, { useState, useEffect } from 'react';

// cleanup function
// second argument

const UseEffectCleanup = () => {
  const [size, setSize] = useState(window.innerWidth);

  const checkSize = () => {
    setSize(window.innerWidth);
  };

  useEffect(() => {
    console.log('useEffect');
    window.addEventListener('resize', checkSize);
    return () => {
      console.log('cleanup');
      window.removeEventListener('resize', checkSize);
    };
  }, []);
  console.log('render');
  return (
    <>
      <h1>window</h1>
      <h2>{size} PX</h2>
    </>
  );
};

export default UseEffectCleanup;


useEffect fetch :-

import React, { useState, useEffect } from 'react';

const url = 'https://api.github.com/users';

// second argument

const UseEffectFetchData = () => {
  const [users, setUsers] = useState([]);

  const getUsers = async () => {
    const response = await fetch(url);
    const users = await response.json();
    setUsers(users);
    // console.log(users);
  };

  useEffect(() => {
    getUsers();
  }, []);
  return (
    <>
      <h3>github users</h3>
      <ul className='users'>
        {users.map((user) => {
          const { id, login, avatar_url, html_url } = user;
          return (
            <li key={id}>
              <img src={avatar_url} alt={login} />
              <div>
                <h4>{login}</h4>
                <a href={html_url}>profile</a>
              </div>
            </li>
          );
        })}
      </ul>
    </>
  );
};

export default UseEffectFetchData;


-----------------------------------------------Conditional Rendering--------------------------------------------------------------------------------------------

Multiple Returns :-

import React, { useState, useEffect } from 'react';
const url = 'https://api.github.com/users/QuincyLarson';
const MultipleReturns = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);
  const [user, setUser] = useState('default user');

  useEffect(() => {
    fetch(url)
      .then((resp) => {
        if (resp.status >= 200 && resp.status <= 299) {
          return resp.json();
        } else {
          setIsLoading(false);
          setIsError(true);
          throw new Error(resp.statusText);
        }
      })
      .then((user) => {
        const { login } = user;
        setUser(login);
        setIsLoading(false);
      })
      .catch((error) => console.log(error));
  }, []);

  if (isLoading) {
    return (
      <div>
        <h1>Loading...</h1>
      </div>
    );
  }
  if (isError) {
    return (
      <div>
        <h1>Error....</h1>
      </div>
    );
  }
  return (
    <div>
      <h1>{user}</h1>
    </div>
  );
};

export default MultipleReturns;



Short-Circuit :-

import React, { useState } from 'react';
// short-circuit evaluation
// ternary operator

const ShortCircuit = () => {
  const [text, setText] = useState('');
  const [isError, setIsError] = useState(false);
  // const firstValue = text || 'hello world';
  // const secondValue = text && 'hello world';

  return (
    <>
      {/* <h1>{firstValue}</h1>
      <h1>value : {secondValue}</h1> */}
      {/* {if(){console.log('hello world')}} */}
      <h1>{text || 'john doe'}</h1>
      <button className='btn' onClick={() => setIsError(!isError)}>
        toggle error
      </button>
      {isError && <h1>Error...</h1>}
      {isError ? (
        <p>there is an error...</p>
      ) : (
        <div>
          <h2>there is no error</h2>
        </div>
      )}
    </>
  );
};

export default ShortCircuit;



Toggle :-

import React, { useState, useEffect } from 'react';

const ShowHide = () => {
  const [show, setShow] = useState(false);
  return (
    <>
      <button className='btn' onClick={() => setShow(!show)}>
        show/hide
      </button>
      {show && <Item />}
    </>
  );
};

const Item = () => {
  const [size, setSize] = useState(window.innerWidth);
  const checkSize = () => {
    setSize(window.innerWidth);
  };
  useEffect(() => {
    window.addEventListener('resize', checkSize);
    return () => {
      window.removeEventListener('resize', checkSize);
    };
  }, []);

  return (
    <div style={{ marginTop: '2rem' }}>
      <h1>Window</h1>
      <h2>size : {size}</h2>
    </div>
  );
};

export default ShowHide;




-----------------------------------------------Forms--------------------------------------------------------------------------------------------


Controlled-Inputs :-

import React, { useState } from 'react';
// JS
// const input = document.getElementById('myText');
// const inputValue = input.value
// React
// value, onChange

const ControlledInputs = () => {
  const [firstName, setFirstName] = useState('');
  const [email, setEmail] = useState('');
  const [people, setPeople] = useState([]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (firstName && email) {
      const person = { id: new Date().getTime().toString(), firstName, email };
      console.log(person);
      setPeople((people) => {
        return [...people, person];
      });
      setFirstName('');
      setEmail('');
    } else {
      console.log('empty values');
    }
  };
  return (
    <>
      <article>
        <form className='form' onSubmit={handleSubmit}>
          <div className='form-control'>
            <label htmlFor='firstName'>Name : </label>
            <input
              type='text'
              id='firstName'
              name='firstName'
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
            />
          </div>
          <div className='form-control'>
            <label htmlFor='email'>Email : </label>
            <input
              type='email'
              id='email'
              name='email'
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <button type='submit'>add person</button>
        </form>
        {people.map((person, index) => {
          const { id, firstName, email } = person;
          return (
            <div className='item' key={id}>
              <h4>{firstName}</h4>
              <p>{email}</p>
            </div>
          );
        })}
      </article>
    </>
  );
};

export default ControlledInputs;




Multiple-Inputs :-

import React, { useState } from 'react';
// JS
// const input = document.getElementById('myText');
// const inputValue = input.value
// React
// value, onChange

const ControlledInputs = () => {
  const [person, setPerson] = useState({ firstName: '', email: '', age: '' });
  const [people, setPeople] = useState([]);
  const handleChange = (e) => {
    const name = e.target.name;
    const value = e.target.value;
    setPerson({ ...person, [name]: value });
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (person.firstName && person.email && person.age) {
      const newPerson = { ...person, id: new Date().getTime().toString() };
      setPeople([...people, newPerson]);
      setPerson({ firstName: '', email: '', age: '' });
    }
  };
  return (
    <>
      <article className='form'>
        <form>
          <div className='form-control'>
            <label htmlFor='firstName'>Name : </label>
            <input
              type='text'
              id='firstName'
              name='firstName'
              value={person.firstName}
              onChange={handleChange}
            />
          </div>
          <div className='form-control'>
            <label htmlFor='email'>Email : </label>
            <input
              type='email'
              id='email'
              name='email'
              value={person.email}
              onChange={handleChange}
            />
          </div>
          <div className='form-control'>
            <label htmlFor='age'>Age : </label>
            <input
              type='number'
              id='age'
              name='age'
              value={person.age}
              onChange={handleChange}
            />
          </div>
          <button type='submit' className='btn' onClick={handleSubmit}>
            add person
          </button>
        </form>
      </article>
      <article>
        {people.map((person) => {
          const { id, firstName, email, age } = person;
          return (
            <div key={id} className='item'>
              <h4>{firstName}</h4>
              <p>{email}</p>
              <p>{age}</p>
            </div>
          );
        })}
      </article>
    </>
  );
};

export default ControlledInputs;




-----------------------------------------------useRef--------------------------------------------------------------------------------------------

useRef - To manage uncontrolled input
         To target Dom Nodes and to change value without rerender
         You can use it in useEffect without any dependency as it does not call rerender

import React, { useEffect, useRef } from 'react';

// preserves value
// DOES NOT trigger re-render
// target DOM nodes/elements

const UseRefBasics = () => {
  const refContainer = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(refContainer.current.value);
  };
  useEffect(() => {
    console.log(refContainer.current);
    if(refContainer.current
    {
      refContainer.current.focus();
    }
  });

  return (
    <>
      <form className='form' onSubmit={handleSubmit}>
        <div>
          <input type='text' ref={refContainer} />
        </div>
        <button type='submit'>submit</button>
      </form>
    </>
  );
};

export default UseRefBasics;

Usage - While scrolling you can use useRef to target a container and then scrollLeft() to scroll to the left
      - When we submit a form, any time on fresh load if we want our first input tag to be highlighted
      - Let any state be changed , If I want to do a specific task after any state change, in useEffect I can call useRef to do that task for any state change.
      - {current: null}
      - refContainer.current === <input type="text" nane="val" id="val"  ref={refContainer}/>

-----------------------------------------------prop-drilling--------------------------------------------------------------------------------------------



import React, { useState } from 'react';
import { data } from '../../../data';
// more components
// fix - context api, redux (for more complex cases)

const PropDrilling = () => {
  const [people, setPeople] = useState(data);
  const removePerson = (id) => {
    setPeople((people) => {
      return people.filter((person) => person.id !== id);
    });
  };
  return (
    <section>
      <h3>prop drilling</h3>
      <List people={people} removePerson={removePerson} />
    </section>
  );
};

const List = ({ people, removePerson }) => {
  return (
    <>
      {people.map((person) => {
        return (
          <SinglePerson
            key={person.id}
            {...person}
            removePerson={removePerson}
          />
        );
      })}
    </>
  );
};

const SinglePerson = ({ id, name, removePerson }) => {
  return (
    <div className='item'>
      <h4>{name}</h4>
      <button onClick={() => removePerson(id)}>remove</button>
    </div>
  );
};

export default PropDrilling;


-----------------------------------------------useContext--------------------------------------------------------------------------------------------


useContext and Context API
createContext returns Producer and Consumer

Earlier we were using Context Api. Consumer was complex. useEffect reduced that complexity.


//Not using object to pass value
<PersonContext.Provider value='Hello'>

const SinglePerson = () => {
  const data = useContext(PersonContext);
  console.log(data);
  return (
    <div className='item'>
      <h4>{data}</h4>
    </div>
  );
};

<PersonContext.Provider value={{removeperson}}>

const SinglePerson = ({ id, name }) => {
  const { removePerson } = useContext(PersonContext);

  return (
    <div className='item'>
      <h4>{name}</h4>
      <button onClick={() => removePerson(id)}>remove</button>
    </div>
  );
};



Example - In One Page :-

import React, { useState, useContext } from 'react';
import { data } from '../../../data';
// more components
// fix - context api, redux (for more complex cases)

const PersonContext = React.createContext();
// two components - Provider, Consumer

const ContextAPI = () => {
  const [people, setPeople] = useState(data);
  const removePerson = (id) => {
    setPeople((people) => {
      return people.filter((person) => person.id !== id);
    });
  };
  return (
    <PersonContext.Provider value={{ removePerson, people }}>
      <h3>Context API / useContext</h3>
      <List />
    </PersonContext.Provider>
  );
};

const List = () => {
  const mainData = useContext(PersonContext);
  console.log(mainData);
  return (
    <>
      {mainData.people.map((person) => {
        return <SinglePerson key={person.id} {...person} />;
      })}
    </>
  );
};

const SinglePerson = ({ id, name }) => {
  const { removePerson } = useContext(PersonContext);

  return (
    <div className='item'>
      <h4>{name}</h4>
      <button onClick={() => removePerson(id)}>remove</button>
    </div>
  );
};

export default ContextAPI;



Example - In Multiple Page :-

// App.js (Combining ThemeContext and App)
import React, { createContext, useState, useContext } from 'react';
import Button from './Button';

const ThemeContext = createContext();

const App = () => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <div className="App">
        <h1>Theme Toggler</h1>
        <Button />
      </div>
    </ThemeContext.Provider>
  );
};

export default App;
export { ThemeContext }; // Exporting ThemeContext for Button.js



// Button.js
import React, { useContext } from 'react';
import { ThemeContext } from './App'; // Importing ThemeContext from App.js

const Button = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <button onClick={toggleTheme}>
      Toggle Theme
    </button>
  );
};

export default Button;
________________________________________________________________________________________________________

Example - Better Version In Multiple Page :-

// ThemeContext.js
import React, { createContext, useState } from 'react';

const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export default ThemeContext;


// Button.js
import React, { useContext } from 'react';
import ThemeContext from './ThemeContext';

const Button = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <button
      style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#333' : '#fff' }}
      onClick={toggleTheme}
    >
      Toggle Theme
    </button>
  );
};

export default Button;


// App.js
import React from 'react';
import { ThemeProvider } from './ThemeContext';
import Button from './Button';

const App = () => {
  return (
    <ThemeProvider>
      <Button />
    </ThemeProvider>
  );
};

export default App;
__________________________________________________________________________________________________________

//ThemeContent.js
import React, { useState, createContext, useContext } from 'react'

const ModeContext = createContext();
const UpdateModeContext = createContext();

export function useTheme() {
    return useContext(ModeContext);
}

export function useThemeUpdate() {
    return useContext(UpdateModeContext);
}

export function ThemeProvider({ children }) {
    const [mode, setMode] = useState("Light")
    return (
        // <ModeContext.Provider value={{ mode, setMode }}>
        <ModeContext.Provider value={mode}>
            <UpdateModeContext.Provider value={setMode}>
                {children}
            </UpdateModeContext.Provider>
        </ModeContext.Provider>
    )
}


//App.js
import React from 'react';
import { ThemeProvider } from "./ThemeContent";
import Mode from "./Mode"
export default function App() {
  return (
    <ThemeProvider>
      <Mode />
    </ThemeProvider>
  )
}


//Mode.js
import React from 'react'
import { useTheme, useThemeUpdate } from "./ThemeContent"

export default function Mode() {
    // const { mode, setMode } = useTheme();
    const mode = useTheme();
    const setMode = useThemeUpdate();

    const myStyle = mode === "Light" ? { backgroundColor: "pink" } : { backgroundColor: "grey" };
    return (
        <div
            // style={{backgroundColor: mode==="Light"?"pink":"grey"}}
            style={myStyle}
        >
            {`Hello I am in ${mode} - mode.`}
            <button onClick={() => setMode((prevMode) => prevMode === "Light" ? "Dark" : "Light")}>{`Toggle ${mode} mode`}</button>
        </div>
    )
}





-----------------------------------------------Points--------------------------------------------------------------------------------------------


We are not allowed to use hooks within a regular function.
Either it needs to be a Component or Custom Hook.

rfc - React Functional Component
rfce - React Functional Component with Export
rfcep - With PropTypes
ptar - PropTypes array isRequired



-----------------------------------------------Data Fetch API--------------------------------------------------------------------------------------------

Api Data Fetching 

import React from 'react';
import PropTypes from 'prop-types';
import defaultImage from '../../../assets/default-image.jpeg';
const Product = ({ image, name, price }) => {
  const url = image && image.url;                                        // If image exists then only it will set image url.
  return (
    <article className='product'>
      <img src={url || defaultImage} alt={name || 'default name'} />    // <img src={IMAGE.URL || defaultImage} alt={name || 'default name'} /> When image is undefined it throws error.                                 	<h4>{name}</h4>                                                                                                                                                               
      <p>${price || 3.99}</p>
    </article>
  );
};

Product.propTypes = {
  image: PropTypes.object.isRequired,
  name: PropTypes.string.isRequired,
  price: PropTypes.number.isRequired,
};
// Product.defaultProps = {
//   name: 'default name',
//   price: 3.99,
//   image: defaultImage,
// };

export default Product;

-----------------------------------------------Router--------------------------------------------------------------------------------------------

Router

When you put path / and /about, then both the page will be displayed. So use exact to prevent this.

------------Basics------------

index.js

import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

const rootElement = document.getElementById("root");

ReactDOM.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
  rootElement
);


App.js

import React from 'react';
import { Routes, Route } from 'react-router-dom';
import Navbar from './Navbar';
import Home from './Home';
import About from './About';

const App = () => {
  return (
    <div>
      <Navbar />
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="*" element={<PageNotFound />} /> {/* Display PageNotFound for unmatched routes */}
        {/* Add more routes as needed */}
      </Routes>
    </div>
  );
};

export default App;


Home.js

import React from 'react';

const Home = () => {
  return (
    <div>
      <h1>I am home</h1>
    </div>
  );
};

export default Home;

About.js

import React from 'react';

const About = () => {
  return (
    <div>
      <h1>About Page</h1>
      <p>This is the about page content.</p>
    </div>
  );
};

export default About;


Navbar.js

import React from 'react';
import { Link } from 'react-router-dom';

const Navbar = () => {
  return (
    <nav>
      <ul>
        <li>
          <Link to="/">Home</Link>
        </li>
        {/* Add more navigation links as needed */}
      </ul>
    </nav>
  );
};

export default Navbar;

-----------------------------------------------memo useMemo useCallback--------------------------------------------------------------------------------------------

useMemo and useCallback are both hooks provided by React, but they serve different purposes:

---------------useMemo:------------------

useMemo is used for memoizing the result of a function. It takes a function and an array of dependencies. It will only recompute the memoized value when one of the dependencies has changed. This helps in optimizing performance by avoiding unnecessary computations.
It is typically used when you have a costly computation that doesn't need to be re-executed on every render if its dependencies haven't changed.
Example: Memoizing the result of a complex computation, such as sorting or filtering an array, to avoid recomputing it on every render.

import React, { useState, useMemo } from 'react';

export default function App() {
  const [number, setNumber] = useState(8);
  const [dark, setDark] = useState(false);

  const doubleNumber = useMemo(() => {
    return slowFunction(number);
  }, [number]);

  const themeStyles = {
    backgroundColor: dark ? 'black' : 'white',
    color: dark ? 'white' : 'black'
  };

  return (
    <>
      <input
        type="number"
        value={number}
        onChange={(e) => setNumber(parseInt(e.target.value))}
      />
      <button onClick={() => setDark(prevDark => !prevDark)}>
        Change Theme
      </button>
      <div style={themeStyles}>{doubleNumber}</div>
    </>
  );
}

function slowFunction(num) {
  console.log('Calling Slow Function');
  for (let i = 0; i <= 1000000000; i++) {}
  return num * 2;
}

---------------useCallback:------------------


useCallback is used to memoize a callback function. It returns a memoized version of the callback that only changes if one of the dependencies has changed.
It is useful when passing callbacks to child components that rely on reference equality to prevent unnecessary re-renders.
Example: Passing callbacks to child components or event handlers in event listeners where you want to ensure that the callback doesn't change unnecessarily.
In summary, both useMemo and useCallback are used for optimization purposes in React applications. useMemo is for memoizing the result of a computation, while useCallback is for memoizing a callback function. They help in avoiding unnecessary recalculations and re-renders, thereby improving performance.

import React, { useState, useCallback } from 'react';
import List from './List.js';

export default function App() {
  const [number, setNumber] = useState(1);
  const [dark, setDark] = useState(false);

  const getItems = useCallback(() => {
    return [number, number + 1, number + 2];
  }, [number]);

  const theme = {
    backgroundColor: dark ? '#333' : '#FFF',
    color: dark ? '#FFF' : '#333'
  };

  return (
    <div style={theme}>
      <input
        type="number"
        value={number}
        onChange={e => setNumber(parseInt(e.target.value))}
      />
      <button onClick={() => setDark(prevDark => !prevDark)}>
        Toggle theme
      </button>
      <List getItems={getItems} />
    </div>
  );
}

import React, { useEffect, useState } from 'react';

export default function List({ getItems }) {
  const [items, setItems] = useState([]);

  useEffect(() => {
    setItems(getItems());
    console.log("Updating Items");
  }, [getItems]);

  return items.map((item, index) => <div key={index}>{item}</div>);
}

---------------React.memo:------------------

In React, when a parent component renders, a child component might un-necessarily render. To optimize this behaviour, you can use React.memo and pass in the child component.
React.memo will perform a shallow comparison of the previous and new props and re-render the child component only if the props have changed.

import React from 'react';
import './App.css';
import { ParentTwo } from './components/Optimization/ParentTwo';

function App() {
  return (
    <div className='App'>
      <ParentTwo />
    </div>
  );
}

export default App;


import React from 'react';

export const ChildTwo = () => {
  console.log('ChildTwo Render');
  return <div>ChildTwo component</div>;
};

export const MemoizedChildTwo = React.memo(ChildTwo);


import React, { useState } from 'react';
import { MemoizedChildTwo } from './ChildTwo';

export const ParentTwo = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('Vishwas');

  console.log('ParentTwo Render');

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count {count}</button>
      <button onClick={() => setName('Codevolution')}>Change name</button>
      <MemoizedChildTwo name={name} />
    </div>
  );
};

-----------------------------------------------useReducer--------------------------------------------------------------------------------------------

------------From useState to useReducer?------------

useReducer is the best solution in React for handling complex state interactions so let’s look at how we can convert a component from useState to useReducer.

function Counter() {
  const [count, setCount] = useState(0)

  function changeCount(amount) {
    setCount(prevCount => prevCount + amount)
  }

  function resetCount() {
    setCount(0)
  }

  return (
    <>
      <span>{count}</span>
      <button onClick={() => changeCount(1)}>+</button>
      <button onClick={() => changeCount(-1)}>-</button>
      <button onClick={() => resetCount()}>Reset</button>
    </>
  )
}

In the above code we have a very simple counter component which can increment, decrement, and reset the count. In order to start converting this to use the useReducer hook we first need to remove the useState call and replace it with useReducer, but before we can do that we need to understand how useReducer is called.


------------Setting Up State------------

Similar to useState, useReducer takes an initial state as one of its arguments and returns to us the current state and a way to update that state. useReducer also re-renders a component when the state changes just like useState. The only major difference is that we also need to pass a reducer function to useReducer which contains all the logic for modifying our state.

const [count, dispatch] = useReducer(reducer, 0)

In the above code you can see that the default state of 0 is passed as the second argument to useReducer and the count is returned as the first element in the array just like with useState. Now instead of having a setCount function we have a dispatch function which allows us to call the reducer function we pass to useReducer. This is a little bit complicated to think about in your head so here is a simple example based on our counter.

function reducer(count, action) {
  switch (action.type) {
    case "increment":
      return count + 1
    default:
      return count
  }
}

const [count, dispatch] = useReducer(reducer, 0)

We now have defined the reducer function and it takes two parameters. The first parameter is the current state of our component. In our case this is just our count. The second parameter is our action which is going to be set to whatever you pass to dispatch. I will cover this more in just a bit. Now inside of the reducer function we have a set of defined actions we can perform on our state. In our case the only action we can perform is the increment action, so if we pass { type: 'increment } to dispatch then it will increase our count by one, otherwise the count will not change.

Essentially, the reducer function takes in a current state as well as an action to perform on the state and it returns the new state. Here is the code we would use to increment our counter.

dispatch({ type: "increment" })

Now that we understand how useReducer initializes and updates state, let’s replace useState with useReducer in our counter component.

function reducer(count, action) {
  switch (action.type) {
    case "increment":
      return count + 1
    case "decrement":
      return count - 1
    case "reset":
      return 0
    default:
      return count
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0)

  return (
    <>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </>
  )
}

As you can see there is no longer any logic inside of our component. The component just tells our reducer what actions to perform and the reducer handles all the complex logic. This is great since it separates out the logic of the state from the component itself and makes it easier to reuse and share this state between components.

What happens if you want to pass data to your reducer, though? This is actually really simple. Since we can pass anything we want to dispatch we can just add our data to the object we pass to dispatch. The common practice is to put all your data inside a property called payload on your object. Here is an example of how to do that.

function reducer(count, action) {
  switch (action.type) {
    case "increment":
      return count + 1
    case "decrement":
      return count - 1
    case "reset":
      return 0
    case "change-count":
      return count + action.payload.amount
    default:
      return count
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0)

  return (
    <>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button
        onClick={() => {
          dispatch({ type: "change-count", payload: { amount: 5 } })
        }}
      >
        Add 5
      </button>
      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </>
  )
}

All we had to do in order to add this new action was create a new section in our reducer to handle this new action. Then we added a call to dispatch to call that action and gave it a payload with the amount we want to change our count by.


------------Cleaning Up Actions------------

One of the biggest downsides to useReducer is that all the actions are defined in strings. This makes it easy to accidentally misspell the action type and cause a bug. One easy way to minimize these types of mistakes is to use a constant object to contain all available actions. This then gives you autocomplete on action types and if you are using TypeScript they can be checked by the compiler. Here is a simple example of that.

const ACTIONS = {
  INCREMENT: "increment",
  DECREMENT: "decrement",
  RESET: "reset",
  CHANGE_COUNT: "change-count",
}

function reducer(count, action) {
  switch (action.type) {
    case ACTIONS.INCREMENT:
      return count + 1
    case ACTIONS.DECREMENT:
      return count - 1
    case ACTIONS.RESET:
      return 0
    case ACTIONS.CHANGE_COUNT:
      return count + action.payload.amount
    default:
      return count
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0)

  return (
    <>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: ACTIONS.INCREMENT })}>+</button>
      <button onClick={() => dispatch({ type: ACTIONS.DECREMENT })}>-</button>
      <button
        onClick={() => {
          dispatch({
            type: ACTIONS.CHANGE_COUNT,
            payload: { amount: 5 },
          })
        }}
      >
        Add 5
      </button>
      <button onClick={() => dispatch({ type: ACTIONS.RESET })}>Reset</button>
    </>
  )
}


------------Conclusion------------
useState is a great way to setup simple state inside of a component. When state starts to get more complex, though, and is shared between multiple components it is generally best to switch to useReducer since useReducer makes it easier to write complex state interactions without creating a large complex mess of code.

-----------------------------------------------React Query--------------------------------------------------------------------------------------------

Read React Query Notes
