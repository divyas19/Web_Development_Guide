-------------------React Query----------------------------

A library for fetching data in React Application.

To use React Query properly, you need to wrap your entire application with a QueryClientProvider, and you need to create and provide a QueryClient instance. Here's how you can set it up:

First, install React Query if you haven't already and other required parts:
npm install react-query
npm install @react-query/devtools
Then, in your App.js, you would set up your QueryClient and wrap your component hierarchy with QueryClientProvider:

App.js
import React from 'react';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from '@react-query/devtools';
import MyComponent from './MyComponent';

// Create a new QueryClient instance
const queryClient = new QueryClient();

const App = () => {
  return (
    // Provide the QueryClient to your app
    <QueryClientProvider client={queryClient}>
      <div className="App">
        <h1>ReactQuery Example</h1>
        <MyComponent />
      </div>
    <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
};

export default App;

Now, you can use useQuery hooks within your components, and React Query will manage the fetching and caching of data for you. Remember that QueryClientProvider should wrap around your entire application to provide access to the QueryClient instance.

import React from 'react';
import { useQuery } from 'react-query';
import axios from 'axios'

const fetchData = async () => {
 return axios.get('http://localhost:4000/superheroes')
};
const MyComponent = () => {

const onSuccess = (data) => {
  console.log('Perform side effect after data fetching',data)
}

const onSuccess = (error) => {
  console.log('Perform side effect after encountering error',error)
}

const { data, isLoading, isError, error, isFetching, refetch } = useQuery('data', fetchData,
{
//cacheTime:5000,
//staleTime:30000,
//enabled:false,
onSuccess,
onError,
select: (data) => {
  const superHeroNames = data.data.map((hero)=> hero.name)
  return superHeroNames
},
);

  if (isLoading || isFetching) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;

  return (
    <div>
      {/* Render your data */}
      <button onClick={refetch}>Fetch Data</button>
      {/* {data?.data.map((elem) => {
        return <div key={elem.name}>{elem.name}</div>
      })} */}
      {data.map((heroName)=> {
        return <div key={heroName}>{heroName}</div>
       })}
    </div>
  );
};

export default MyComponent;


In React Query, the staleTime option determines how long the data fetched by a query remains considered "fresh" in the cache. If a component requests the data while it's within this "stale" period, React Query will return the cached data immediately without making a new request to the server. However, if the data is requested after the staleTime period has passed, React Query will automatically trigger a background refetch of the data before returning it to the component.

In React Query, the staleTime option is used to determine how long the data fetched by a query remains considered "fresh" in the cache.

When a component requests the data, React Query checks if the cached data is stale based on the staleTime. If the cached data is still considered fresh (i.e., the time since it was fetched is less than staleTime), React Query returns the cached data immediately without making a new request to the server. This enhances performance by reducing unnecessary network requests and providing a more responsive user experience.

However, if the cached data is considered stale (i.e., the time since it was fetched exceeds staleTime), React Query will still return the cached data immediately to the component. Additionally, it will trigger a background fetch request to update the cached data. This ensures that the data remains up-to-date while still providing a responsive user experience.
However, if you're referring to a hypothetical cacheTime option in the context of React Query, it could potentially represent the duration for which the data remains in the cache before being considered stale.


Other options:-

const { data } = useQuery('key', fetchData, {
  refetchOnMount: false, // Disable automatic refetch on mount
});

const { data } = useQuery('key', fetchData, {
  refetchOnWindowFocus: false, // Disable automatic refetch on window focus
});

const { data } = useQuery('key', fetchData, {
  refetchInterval: 5000, // Refetch every 5 seconds (5000 milliseconds)
});

//Data poll
const { data } = useQuery('key', fetchData, {
  refetchIntervalInBackground: 10000, // Refetch every 10 seconds (10000 milliseconds) in background
});

//Data transformation using fetch
select

__________________________________________________________________________________________________________________________

Custom Query

useSuperHeroesData.js
import { useQuery } from 'react-query';
import axios from 'axios'

const fetchData = async () => {
 return axios.get('http://localhost:4000/superheroes')
};

export const useSuperHeroesData = (onSuccess, onError) => {
 return useQuery('data', fetchData,
{
//cacheTime:5000,
//staleTime:30000,
//enabled:false,
onSuccess,
onError,
select: (data) => {
  const superHeroNames = data.data.map((hero)=> hero.name)
  return superHeroNames
},
);
}


MyComponent.js
import React from 'react';
import { useSuperHeroesData } from '../hooks/useSuperHeroesData'

const MyComponent = () => {

const onSuccess = (data) => {
  console.log('Perform side effect after data fetching',data)
}

const onSuccess = (error) => {
  console.log('Perform side effect after encountering error',error)
}

const { data, isLoading, isError, error, isFetching, refetch } = useSuperHeroesData(onSuccess,onError);

  if (isLoading || isFetching) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;

  return (
    <div>
      {/* Render your data */}
      <button onClick={refetch}>Fetch Data</button>
      {/* {data?.data.map((elem) => {
        return <div key={elem.name}>{elem.name}</div>
      })} */}
      {data.map((heroName)=> {
        return <div key={heroName}>{heroName}</div>
       })}
    </div>
  );
};

export default MyComponent;

__________________________________________________________________________________________________________________________

Query By ID

// App.js
import React from 'react';
import { QueryClient, QueryClientProvider } from 'react-query';
import MyComponent from './MyComponent';

const queryClient = new QueryClient();

const App = () => {
  return (
    <QueryClientProvider client={queryClient}>
      <div className="App">
        <h1>ReactQuery Example</h1>
        {/* Pass the desired ID to MyComponent */}
        <MyComponent id={123} />
      </div>
    </QueryClientProvider>
  );
};

export default App;


// MyComponent.js
import React from 'react';
import { useQuery } from 'react-query';

const fetchDataById = async (id) => {
  const response = await fetch(`https://api.example.com/data/${id}`);
  if (!response.ok) {
    throw new Error('Failed to fetch data');
  }
  return response.json();
};

{/*
const fetchDataById = async ({queryKey) => {
  const id = queryKey[1];
  const response = await fetch(`https://api.example.com/data/${id}`);
  if (!response.ok) {
    throw new Error('Failed to fetch data');
  }
  return response.json();
};
*/}

const MyComponent = ({ id }) => {
  const { data, isLoading, isError, error } = useQuery(['data', id], () => fetchDataById(id));
  {/*const { data, isLoading, isError, error } = useQuery(['data', id],fetchDataById);*/

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;

  return (
    <div>
      {/* Render your data */}
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
};

export default MyComponent;

__________________________________________________________________________________________________________________________

Parallel Queries

import React from 'react';
import axios from 'axios';
import { useQuery } from 'react-query';

const fetchUserData = async () => {
  const response = await axios.get('https://api.example.com/user');
  return response.data;
};

const fetchPostsData = async () => {
  const response = await axios.get('https://api.example.com/posts');
  return response.data;
};

const UserProfile = () => {
  const { data: userData, isLoading: isUserLoading, isError: isUserError, error: userError } = useQuery('userData', fetchUserData);

  const { data: postsData, isLoading: isPostsLoading, isError: isPostsError, error: postsError } = useQuery('postsData', fetchPostsData);

  if (isUserLoading || isPostsLoading) return <div>Loading...</div>;
  if (isUserError) return <div>Error loading user data: {userError.message}</div>;
  if (isPostsError) return <div>Error loading posts data: {postsError.message}</div>;

  return (
    <div>
      <h1>User Profile</h1>
      <h2>User Data</h2>
      <pre>{JSON.stringify(userData, null, 2)}</pre>
      <h2>Posts Data</h2>
      <pre>{JSON.stringify(postsData, null, 2)}</pre>
    </div>
  );
};

export default UserProfile;

__________________________________________________________________________________________________________________________

Dynamic Parallel Queries

import React from 'react';
import { QueryClient, QueryClientProvider } from 'react-query';
import UserProfile from './UserProfile';

const queryClient = new QueryClient();

const App = () => {
  // Array of user IDs
  const userIds = [1, 3];

  return (
    <QueryClientProvider client={queryClient}>
      <div className="App">
        {/* Pass the array of user IDs to UserProfile */}
        <UserProfile userIds={userIds} />
      </div>
    </QueryClientProvider>
  );
};

export default App;

import React from 'react';
import axios from 'axios';
import { useQueries } from 'react-query';

const fetchUserData = async (id) => {
  const response = await axios.get(`https://api.example.com/user/${id}`);
  return response.data;
};

const fetchPostData = async (userId) => {
  const response = await axios.get(`https://api.example.com/posts?userId=${userId}`);
  return response.data;
};

const UserProfile = ({ userIds }) => {
  // Array of query objects
  const queries = userIds.map(userId => {
    return {
      queryKey: ['userData', userId],
      queryFn: () => fetchUserData(userId)
    };
  });

  // Execute all queries in parallel
  const results = useQueries(queries);

  return (
    <div>
      <h1>User Profiles</h1>
      {results.map((result, index) => {
        if (result.isLoading) return <div key={index}>Loading...</div>;
        if (result.isError) return <div key={index}>Error: {result.error.message}</div>;
        return (
          <div key={index}>
            <h2>User Data for userId {userIds[index]}</h2>
            <pre>{JSON.stringify(result.data, null, 2)}</pre>
          </div>
        );
      })}
    </div>
  );
};

export default UserProfile;

